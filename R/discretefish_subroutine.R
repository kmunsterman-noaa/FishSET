# discretefish_subroutine
#' Run discrete choice model
#'
#' Subroutine to run chosen discrete choice model. Function pulls necessary data generated in \code{\link{make_model_design}} and loops through model design choices and expected catch cases. Output is saved to the FishSET database.
#'
#' @param project  String, name of project.
#' @param select.model Return an interactive data table that allows users to select and save table of best models based on measures of fit.
#' @param explorestarts Logical, should starting parameters value space be explored? Set to TRUE if unsure of the number of 
#'    starting parameter values to include or of reasonable starting parameters values. Better starting parameter values
#'    can help with model convergence.
#' @param breakearly Logical, if explorestarts is TRUE, should the first set of starting parameter values that returns a valid (numeric)
#'   loglikelihoood value be returned (TRUE) or should the entire parameter space be considered and the set of starting parameter values 
#'   that return the lowest loglikelihood value be returned (FALSE).
#' @param space Specify if \code{explorestarts = TRUE}. List of length 1 or length equal to the number of models to be evaluated.
#'   \code{space} is the number of starting value permutations to test (the size of
#'   the space to explore). The greater the \code{dev} argument, the larger the
#'   \code{space} argument should be.
#' @param dev Specify if \code{explorestarts = TRUE}. List of length 1 or length equal to the number of models to be evaluated.
#'   \code{dev} refers to how far to deviate from the average parameter values when
#'   exploring (random normal deviates). The less certain the average parameters are,
#'   the greater the \code{dev} argument should be.
#' @param use.scalers Logical, should data be noramalized? Defaults to TRUE. Rescaling factors are the mean of the numeric vector unless specified with \code{scaler}.
#' @param scaler.func Function to calculate rescaling factors. Can be a generic function, such as mean, or a user-defined function.
#'   User-defined functons must be specified as \code{scaler.fun = function(x, FUN=sd) 2*FUN(x)}. This example returns 2 times the standard deviation of \code{x}.

#' @export discretefish_subroutine
#' @importFrom DBI dbExecute dbWriteTable dbExistsTable dbReadTable dbGetQuery dbDisconnect
#' @importFrom DT datatable JS DTOutput
#' @importFrom stats optim
#' @import shiny
#' @details Runs through model design choices generated by \code{\link{make_model_design}} and stored as `modelInputData` in 
#'     FishSET database.  Data matrix is created in \code{\link{create_model_input}}. 
#'     Required data, optional data, and details on likelihood functions are outlined in \code{\link{make_model_design}}. \cr\cr\cr
#'
#' Likelihood-specific initial parameter estimates: \cr
#'
#'  logit_c: \verb{  } Conditional logit likelihood \cr
#'   \verb{    }Starting parameter values takes the order of: c([alternative-specific parameters],  [travel-distance parameters]). \cr \cr
#'    The alternative-specific parameters and travel-distance parameters are of length (# of alternative-specific variables) and (# of
#'     travel-distance variables) respectively.
#'
#'  logit_avgcat:\verb{  } Average catch multinomial logit procedure \cr
#'    \verb{    } Starting parameters takes the order of: c([average-catch parameters], [travel-distance parameters]). \cr \cr
#'    The average-catch and travel-distance parameters are of length (# of average-catch variables)*(k-1) and (# of travel-distance variables)
#'    respectively, where (k) equals the number of alternative fishing choices.
#'
#'  logit_correction: \verb{  } Full information model with Dahl's correction function \cr
#'    \verb{    } Starting parameter values takes the order of: c([marginal utility from catch], [catch-function parameters],
#'    [polynomial starting parameters], [travel-distance parameters], [catch sigma]). \cr \cr
#'    The number of polynomial interaction terms is currently set to 2, so given the chosen degree 'polyn' there should be
#'     \code{"(((polyn+1)*2)+2)*(k)"} polynomial starting parameters, where (k) equals the number of alternative fishing choices.
#'    The marginal utility from catch and catch sigma are of length equal to unity respectively. The catch-function and
#'    travel-distance parameters are of length (# of catch variables)*(k) and (# of cost variables) respectively.
#'
#'  epm_normal: \verb{  } Expected profit model with normal catch function \cr
#'    \verb{    }Starting parameters values take the order of: c([catch-function parameters], [travel-distance parameters], [catch sigma(s)], [scale parameter]). \cr \cr
#'    The catch-function and travel-distance parameters are of length (# of catch-function variables)*(k) and (# of travel-distance
#'    variables) respectively, where (k) equals the number of alternative fishing choices. The catch sigma(s) are either of length equal
#'    to unity or length (k) if the analyst is estimating location-specific catch sigma parameters. The scale parameter is of length
#'    equal to unity.
#'
#'  epm_weibull: \verb{  } Expected profit model with Weibull catch function \cr,
#'   \verb{    } Starting parameter values takes the order of: c([catch-function parameters], [travel-distance parameters], [catch sigma(s)], [scale parameter]). \cr \cr
#'    The catch-function and travel-distance parameters are of length (# of catch-function variables)*(k) and (# of travel-distance variables)
#'    respectively, where (k) equals the number of alternative fishing choices. The catch sigma(s) are either of length equal to unity or
#'    length (k) if the analyst is estimating location-specific catch sigma parameters. The scale parameter is of length equal to unity.
#'
#'  epm_lognormal: \verb{ } Expected profit model with lognormal catch function \cr
#'    \verb{    } Starting parameter values takes the order of: c([catch-function parameters], [travel-distanceparameters],
#'    [catch sigma(s)], [scale parameter]). \cr\cr
#'    The catch-function and travel-distance parameters are of length (# of
#'    catch-function variables)*(k) and (# of travel-distance variables) respectively, where (k) equals the number of alternative fishing choices.
#'    The catch sigma(s) are either of length equal to unity or length (k) if the analyst is estimating location-specific catch sigma parameters.
#'    The scale parameter is of length equal to unity.
#'  \cr\cr\cr
#'
#'    Model output are saved to the FishSET database and can be loaded to the console with:
#'    \tabular{rlll}{
#'    \code{\link{model_out_view}}: \tab model output including optimization information, standard errors, coefficients, and t- statistics. \cr
#'    \code{\link{model_fit}}: \tab model comparison metrics \cr
#'    \code{\link{globalcheck_view}}: \tab  model error message \cr
#'      }
#'    For obtaining catch, choice, distance, and otherdat data generated from \code{make_model_design} function.
#'    Working modelInputData table (table without date) will be pulled from FishSET database.
#'
#' @return
#' \tabular{rlll}{
#'   OutLogit: \tab [outmat1 se1 EPM2] (coefs, ses, tstats) \cr
#'   optoutput: \tab optimization information \cr
#'   seoumat2: \tab ses \cr
#'   MCM: \tab Model Comparison metrics \cr
#' }
#' @examples
# # choice <- as.data.frame(modelInputData$choice)
# # alt.choice <- as.data.frame(as.numeric(as.factor(as.numeric(as.data.frame(modelInputData$choice)[,1]))))
# # griddatfin <- list(predicted_catch=modelInputData$gridVaryingVariables$matrix)
# # intdatfin <- list(modelInputData$bCHeader[[-1]])
#' \dontrun{
#' results <- discretefish_subroutine("pcod", select.model = TRUE)
#' }
#'
discretefish_subroutine <- function(project, select.model = FALSE, explorestarts = TRUE, breakearly= TRUE,
                                    space=NULL, dev=NULL, use.scalers=TRUE, scaler.func=NULL) {

  
end <- FALSE

    if (!isRunning()) { # if run in console
    
    check <- checklist(project)
    end <- any(vapply(check, function(x) x$pass == FALSE, logical(1)))
  }

   
  if (end == FALSE) {

    # Call in datasets
        if(table_exists(paste0(project, "modelinputdata"), project)){
          fishset_db <- DBI::dbConnect(RSQLite::SQLite(), locdatabase(project=project))

           x_temp <- unserialize(DBI::dbGetQuery(fishset_db, paste0("SELECT ModelInputData FROM ", project, "modelinputdata LIMIT 1"))$ModelInputData[[1]])

        } else {
          warning('Model input table does not exist.')
          end <- TRUE
        }
  }

  if(end == FALSE){
    for (i in 1:length(x_temp)) {

      x <- x_temp[[i]]
 #     if (!is.null(x$mod.name) & x$likelihood!='logit_c'){
 #           exp.names <- NULL
  #    } else {
   #     exp.names <- list()
  #    }
      
   
#      for(k in 1:length(x$expectcatchmodels)){
#        if(any(x$expectcatchmodels[[k]]=='individual')){
#          explen <- length(exp.names)
#          g <- list(c("short_exp"),c("short_exp_newDumV"),c("med_exp"),c("med_exp_newDumV"),c("long_exp"),c("long_exp_newDumv"),c("user_defined_exp"))
#          for(i in 1:length(g)){
#             exp.names[[explen+i]] <- g[[i]]
#            }
#        } else {
#        exp.names[[length(exp.names)+1]] <- defineexp(x$expectcatchmodels[[k]])
#        }
 #     }
     
        if(x$expectcatchmodels == 'individual') {
          length.exp.names <-length(x$gridVaryingVariables)
        } else {
          length.exp.names <- 1
        }
      
        for(j in 1:length(length.exp.names)){
          if(length.exp.names==1){
          datamatrix <- create_model_input(project=project, x=x, mod.name=x$mod.name, use.scalers= use.scalers, scaler.func=scaler.func, expected.catch=x$gridVaryingVariables)
          } else {
            datamatrix <- create_model_input(project=project, x=x, mod.name=x$mod.name, use.scalers= use.scalers, scaler.func=scaler.func, expected.catch=x$gridVaryingVariables[j])  
          }
          
      if (is.factor(x$optimOpt)) {
            opt <- as.numeric(unlist(strsplit(as.character(x$optimOpt), " ")))
          } else if(is.list(x$optimOpt)){
            opt <- as.numeric(unlist(x$optimOpt))
          } else {
            opt <- as.numeric(unlist(strsplit(as.character(x$optimOpt), " ")))
          }
      
          if (is.factor(x$initparams)) {
            starts2 <- as.numeric(unlist(strsplit(as.character(x$initparams), ","))) # inits
          } else if(is.list(x$initparams)){
            starts2 <- unlist(x$initparams)
          } else {
            starts2 <-as.numeric(unlist(strsplit(as.character(x$initparams), ","))) # inits
          }
      
#      choice.table <- as.matrix(choice, as.numeric(factor(choice)))
#      choice <- data.frame(as.matrix(as.numeric(factor(choice))))
#      ab <- max(choice) + 1 # no interactions in create_logit_input - interact distances in likelihood function instead
      
      errorExplain <- NULL
      OutLogit <- NULL
      optoutput <- NULL
      seoutmat2 <- NULL
      MCM <- NULL
      H1 <- NULL
      fr <- x$likelihood # func  #e.g. logit_c
      fr.name <- match.fun(find_original_name(match.fun(as.character(fr))))
      
        
        #Number of inits
        gridNum <- length(datamatrix$otherdat$griddat[[1]])
        intNum <-  length(datamatrix$otherdat$intdat[[1]])
        if(fr == 'logit_c'){
          numInits <- gridNum+intNum
        } else if(fr == 'logit_avgcat') {
          numInits <- gridNum*(max(datamatrix$choice)-1)+intNum
        } else if(fr == 'logit_correction'){
          numInits <- gridNum*max(datamatrix$choice) + intNum + ((((as.numeric(x_temp[[i]]$polyn)+1)*2)+2)*max(datamatrix$choice)) +1+1
          
        } else {
#          if(input$lockk=='TRUE'){
#            numInits <- gridNum*max(choice)+intNum+alt+1
#          } else {
            numInits <- gridNum*max(datamatrix$choice)+intNum+1+1
#          }
        }
        if(numInits != length(starts2)){
          if(numInits > length(starts2)){
            starts2 <- c(starts2, rep(0.5, (numInits - length(starts2))))
            message(numInits, ' initial parameter values should be specified')
          } else if (numInits < length(starts2)){
            starts2 <- starts2[1:numInits]
            message(numInits, ' initial parameter values should be specified')
          } else {
            starts2 <- starts2
          }
        }

        #Explore starting parameters
        if(explorestarts==TRUE){
          sp <- if(is_empty(space[i])) {10} else { space[i] }
          devr <- if(is_empty(dev[i])) { 5} else { dev[i] }
          
          starts2 <- explore_startparams_discrete(space=sp, dev=devr, breakearly=breakearly, startsr=starts2, fr=fr, 
                                                  d=datamatrix$d, otherdat=datamatrix$otherdat, choice=datamatrix$choice, project=project)
        }
        
        
        LL_start <- fr.name(starts2, datamatrix$d, datamatrix$otherdat, max(datamatrix$choice), 
                            project =project, datamatrix$expname, as.character(datamatrix$mod.name))
        
        if (is.null(LL_start) || is.nan(LL_start) || is.infinite(LL_start)) {
          # haven't checked what happens when error yet
          errorExplain <- "Initial function results bad (Nan, Inf, or undefined), check 'ldglobalcheck'"
          cat("Initial function results bad (Nan, Inf, or undefined), check 'ldglobalcheck'")
          next
        }

        #############################################################################
        res <- c()
        mIter <- opt[1] # should add something to default options here if not specified
        relTolX <- opt[2]
        reportfreq <- opt[3]
        detailreport <- opt[4]
        
        controlin <- list(trace = detailreport, maxit = mIter, reltol = relTolX, REPORT = reportfreq)
        
        res <- tryCatch(
          {
            stats::optim(starts2, fr.name,
                         dat = datamatrix$d, otherdat = datamatrix$otherdat, alts = max(datamatrix$choice), 
                         method = as.character(x_temp[[i]][['methodname']]), control = controlin, hessian = TRUE, 
                         project = project, expname = datamatrix$expname, mod.name = as.character(unlist(x_temp[[i]][['mod.name']]))
            )
          },
          error = function(e) {
            return("Optimization error, check 'ldglobalcheck'")
          }
        )
        
        
        fishset_db <- DBI::dbConnect(RSQLite::SQLite(), locdatabase(project=project))
        single_sql <- paste0(project, "ldglobalcheck", format(Sys.Date(), format = "%Y%m%d"))
        second_sql <- paste("INSERT INTO", single_sql, "VALUES (:data)")
        
        
         if (table_exists(single_sql, project=project) == TRUE) {
           if(any(is_empty(unlist(DBI::dbGetQuery(fishset_db, paste0("SELECT data FROM ", single_sql, " LIMIT 1"))$data)))) {
             table_remove(single_sql, project)
            ldglobalcheck <- ldglobalcheck
           } else {
            x <- unserialize(DBI::dbGetQuery(fishset_db, paste0("SELECT data FROM ", single_sql, " LIMIT 1"))$data[[1]])
           table_remove(single_sql, project=project)
           ldglobalcheck <- c(x, ldglobalcheck)
         }
         }
        
        DBI::dbExecute(fishset_db, paste0("CREATE TABLE IF NOT EXISTS ", project, "ldglobalcheck", format(Sys.Date(), format = "%Y%m%d"), "(data ldglobalcheck)"))
        DBI::dbExecute(fishset_db, second_sql, params = list(data = list(serialize(ldglobalcheck, NULL))))
        
        
        if (res[[1]][1] == "Optimization error, check 'ldglobalcheck'") {
          print(list(
            error=paste('optimization error for', x_temp[[i]]$mod.name,', check ldglobalcheck'),
            name = names(x_temp[[i]][["gridVaryingVariables"]])[i], errorExplain = res, OutLogit = OutLogit, optoutput = optoutput,
            seoutmat2 = seoutmat2, MCM = MCM, H1 = H1
          ))
          next
        }
        
        q2 <- res[["par"]]
        
        
        LL <- res[["value"]]
        output <- list(
          counts = res[["counts"]], convergence = res[["convergence"]],
          optim_message = res[["message"]]
        )
        H <- res[["hessian"]]
        
    
        #############################################################################
        # Model comparison metrics (MCM)
        param <- max(dim(as.matrix(starts2)))
        obs <- dim(datamatrix$dataCompile)[1]
        AIC <- round(2 * param - 2 * LL, 3)
        
        AICc <- round(AIC + (2 * param * (param + 1)) / (obs - param - 1), 3)
        
        BIC <- round(-2 * LL + param * log(obs), 3)
        
        PseudoR2 <- round((LL_start - LL) / LL_start, 3)
        if (!exists("mod.out")) {
          mod.out <- data.frame(matrix(NA, nrow = 4, ncol = 1))
          mod.out[, 1] <- c(AIC, AICc, BIC, PseudoR2)
          rownames(mod.out) <- c("AIC", "AICc", "BIC", "PseudoR2")
          colnames(mod.out) <- paste0(datamatrix$expname, x_temp[[i]][["mod.name"]])
        } else {
          temp <- data.frame(c(AIC, AICc, BIC, PseudoR2))
          colnames(temp) <- paste0(datamatrix$expname, x_temp[[i]][["mod.name"]])
        }
        

        if (i == 1) {
          if(table_exists(paste0(project, "modelfit"), project)){
          table_remove(paste0(project, "modelfit"), project)
          }
          DBI::dbWriteTable(fishset_db, paste0(project, "modelfit"), mod.out)
        } else {
          out.mod <- DBI::dbReadTable(fishset_db, paste0(project, "modelfit"))
          if (exists("temp")) {
            out.mod <- cbind(out.mod, temp)
          } else {
            out.mod <- cbind(out.mod, mod.out)
          }
          
          if (any(duplicated(colnames(out.mod))) == T) {
            warning("Duplicate columns names. Adding numeric identifer to make colnames unique.")
            colnames(out.mod) <- paste0(colnames(out.mod), 1:length(colnames(out.mod)))
          }
          DBI::dbWriteTable(fishset_db, paste0(project, "modelfit"), out.mod, overwrite = T)
        }
        
        ### Full model output
        MCM <- list(AIC = AIC, AICc = AICc, BIC = BIC, PseudoR2 = PseudoR2)
        
        if (is.null(H) == FALSE) {
          Htrial <- function(x) {
            Htrial <- tryCatch(
              {
                solve(H)
              },
              error = function(e) {
                return("Error, singular, check 'ldglobalcheck'")
              }
            )
            Htrial
          }
          print(Htrial(H))
          H1 <- Htrial(H)

          
          diagtrial <- function(x) {
            diagtrial <- tryCatch(
              {
                diag(H1)
              },
              error = function(e) {
                return("Error, NAs, check 'ldglobalcheck'")
              }
            )
            diagtrial
          }
          
          if (H1[1] != "Error, singular, check 'ldglobalcheck'") {
            diag2 <- diagtrial(H1)
            print(diag2)
          }
          
          
          if (H1[1] != "Error, singular, check 'ldglobalcheck'"){
            if(diag2[1] != "Error, NAs, check 'ldglobalcheck'") {
              se2 <- tryCatch(
                {
                  sqrt(diag2)
                },
                warning = function(war) {
                  print("Cannot compute standard error. Check 'ldglobalcheck'")
                  sqrt(diag2)
                }
              )
            } else {
              warning = function(war) {
                print("Cannot compute standard error. Check 'ldglobalcheck'")
              }
            }
          }
         
          if (H1[1] != "Error, singular, check 'ldglobalcheck'"){
            if(se2[1]!="Cannot compute standard error. Check 'ldglobalcheck'") {
            outmat2 <- t(q2) #best set of parameters found
            seoutmat2 <- t(se2) #standard errors
            optoutput <- output #optimization info - counts, convergence, optimization error
            tLogit <- t(outmat2 / se2)
            OutLogit <- cbind(t(outmat2), as.matrix(se2), (tLogit))
          }
        }
        
       # if(H1[1]=="Error, singular, check 'ldglobalcheck'") next
       # if (H1[1] != "Error, singular, check 'ldglobalcheck'") {
        if(!exists("modelOut")) {
          modelOut <- list()
          modelOut[[length(modelOut) + 1]] <- list(
            name = datamatrix$expname, errorExplain = errorExplain, OutLogit = OutLogit, optoutput = optoutput,
            seoutmat2 = seoutmat2, MCM = MCM, H1 = H1, choice.table = datamatrix$choice.table, params=outmat2
          )
        } else {
          modelOut[[length(modelOut) + 1]] <- list(
            name = datamatrix$expname, errorExplain = errorExplain, OutLogit = OutLogit, optoutput = optoutput,
            seoutmat2 = seoutmat2, MCM = MCM, H1 = H1, choice.table = datamatrix$choice.table, params=outmat2
          )
        } 
        raw_sql <- paste0(project, "modelOut")
        single_sql <- paste0(project, "modelOut", format(Sys.Date(), format = "%Y%m%d"))
        if (table_exists(single_sql, project)) {
          table_remove(single_sql, project)
        }
        if (table_exists(raw_sql, project)) {
          table_remove(raw_sql, project)
        }
        
        # save param ests, se, and t-vals to output folder
        if(!is.null(OutLogit)) {
          
          params_out <- as.data.frame(OutLogit)
          names(params_out) <- c("estimate", "std_error", "t_value") 
          rownames(params_out)[1:length(sort(unique(x_temp[[i]]$choice)[,1]))] <- sort(unique(x_temp[[i]]$choice)[,1])
          params_out <- round(params_out, 3)

          save_table(params_out, project=project, x_temp[[i]]$mod.name)

#          save_table(params_out, paste0(project, '_params'), x_temp[[i]]$mod.name)
        }
        
        second_sql <- paste("INSERT INTO", single_sql, "VALUES (:data)")
        raw_second_sql <- paste("INSERT INTO", raw_sql, "VALUES (:data)")
        DBI::dbExecute(fishset_db, paste("CREATE TABLE IF NOT EXISTS", single_sql, "(data modelOut)"))
        DBI::dbExecute(fishset_db, second_sql, params = list(data = list(serialize(modelOut, NULL))))
        DBI::dbExecute(fishset_db, paste("CREATE TABLE IF NOT EXISTS", raw_sql, "(data modelOut)"))
        DBI::dbExecute(fishset_db, raw_second_sql, params = list(data = list(serialize(modelOut, NULL))))
        DBI::dbDisconnect(fishset_db)

        } else {
          print("Model error, check 'ldglobalcheck'")
        }
      }## End looping through expected catch cases
    } # end looping through model choices
   
    } # end model run (if end == false)
    # out.mod <<- out.mod
    on.exit(DBI::dbDisconnect(fishset_db), add = TRUE)
    #############################################################################
    if (select.model == TRUE) {
      #  rownames(out.mod)=c("AIC", "AICc", "BIC", "PseudoR2")
      #   print(DT::datatable(t(round(out.mod, 5)), filter='top'))
      
      shiny::runApp(list(
        ui = shiny::basicPage(
          h2("Model Output"),
          DT::DTOutput("mytable"),
          h3(""),
          actionButton("submit", "Save table", style = "color: #fff; background-color: #337ab7; border-color: #2e6da4;display:inline-block;width:12%;text-align: center;"),
          tags$button(
            id = "close",
            type = "button",
            style = "color: #fff; background-color: #FF6347; border-color: #800000; display:inline-block;width:12%;text-align: center;margin-left:10px",
            class = "btn action-button",
            onclick = "setTimeout(function(){window.close();},500);", # close browser
            "Close window"
          )
        ),
        
        server = function(input, output) {
          # helper function for making checkbox
          shinyInput <- function(FUN, len, id, ...) {
            inputs <- character(len)
            for (i in seq_len(len)) {
              inputs[i] <- as.character(FUN(paste0(id, i), label = NULL, ...))
            }
            inputs
          }
          # datatable with checkbox
          output$mytable <- shiny::renderDataTable(
            {
              data.frame(t(out.mod), Select = shinyInput(checkboxInput, nrow(t(out.mod)), "cbox_"))
            },
            colnames = c("model", "AIC", "AICc", "BIC", "PseudoR2"),
            filter = "top",
            server = FALSE,
            escape = FALSE,
            options = list(
              paging = FALSE,
              preDrawCallback = DT::JS("function() { 
                                   Shiny.unbindAll(this.api().table().node()); }"),
              drawCallback = DT::JS("function() { 
                                Shiny.bindAll(this.api().table().node()); } ")
            )
          )
          # helper function for reading checkbox
          
          shinyValue <- function(id, len) {
            unlist(lapply(seq_len(len), function(i) {
              value <- input[[paste0(id, i)]]
              if (is.null(value)) NA else value
            }))
          }
          
          shinyDate <- function(id, len) {
            unlist(lapply(seq_len(len), function(i) {
              # value = input[[paste0(id, i)]]
              # if (is.null(value)) NA else value
              value <- ifelse(input[[paste0(id, i)]] != TRUE, "", as.character(Sys.Date()))
            }))
          }
          
          checkedsave <- reactive(cbind(
            model = colnames(out.mod), t(out.mod),
            selected = shinyValue("cbox_", nrow(t(out.mod))),
            Date = shinyDate("cbox_", nrow(t(out.mod)))
          ))
          
          
          # When the Submit button is clicked, save the form data
          observeEvent(input$submit, {
            # Connect to the database
            #fishset_db <- DBI::dbConnect(RSQLite::SQLite(), locdatabase(project=project))
            single_sql <- paste0(project, "modelChosen")
            if (DBI::dbExistsTable(fishset_db, single_sql) == FALSE) {
              DBI::dbExecute(fishset_db, paste0("CREATE TABLE ", single_sql, "(model TEXT, AIC TEXT, AICc TEXT, BIC TEXT, PseudoR2 TEXT, selected TEXT, Date TEXT)"))
            }
            # Construct the update query by looping over the data fields
            query <- sprintf(
              "INSERT INTO %s (%s) VALUES %s",
              single_sql,
              paste(names(data.frame(as.data.frame(isolate(checkedsave())))), collapse = ", "),
              paste0("('", matrix(apply(as.data.frame(isolate(checkedsave())), 1, paste, collapse = "','"), ncol = 1), collapse = ",", "')")
            )
            # Submit the update query and disconnect
            DBI::dbGetQuery(fishset_db, query)
            showNotification("Table saved to database")
            
            #Save 
          })
          
          # stop shiny
          observe({
            if (input$close > 0) stopApp()
          })
        }
      ))
    } # end select.model
    
    #############################################################################
    discretefish_subroutine_function <- list()
    discretefish_subroutine_function$functionID <- "discretefish_subroutine"
    discretefish_subroutine_function$args <- list(project, select.model)
    discretefish_subroutine_function$kwargs <- list()
    log_call(project, discretefish_subroutine_function)
    #############################################################################
    single_sql <- paste0(project, "modelOut", format(Sys.Date(), format = "%Y%m%d"))
    if (table_exists(single_sql, project)) {
      fishset_db <- DBI::dbConnect(RSQLite::SQLite(), locdatabase(project=project))
      out <- unserialize(DBI::dbGetQuery(fishset_db, paste0("SELECT data FROM ", single_sql, " LIMIT 1"))$data[[1]])
      # return(out)
      DBI::dbDisconnect(fishset_db)
    }

}

