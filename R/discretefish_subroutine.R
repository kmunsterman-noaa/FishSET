#' Run discrete choice model
#'
#' Subroutine to run chosen discrete choice model. Function pulls necessary data 
#' generated in \code{\link{make_model_design}} and loops through model design 
#' choices and expected catch cases. Output is saved to the FishSET database.
#'
#' @param project  String, name of project.
#' @param select.model Return an interactive data table that allows users to 
#'   select and save table of best models based on measures of fit.
#' @param explorestarts Logical, should starting parameters value space be explored? 
#'   Set to \code{TRUE} if unsure of the number of starting parameter values to 
#'   include or of reasonable starting parameters values. Better starting parameter 
#'   values can help with model convergence.
#' @param breakearly Logical, if \code{explorestarts = TRUE}, should the first set 
#'   of starting parameter values that returns a valid (numeric) loglikelihood 
#'   value be returned (\code{TRUE}) or should the entire parameter space be considered 
#'   and the set of starting parameter values that return the lowest loglikelihood 
#'   value be returned (\code{FALSE}).
#' @param space Specify if \code{explorestarts = TRUE}. List of length 1 or length 
#'   equal to the number of models to be evaluated. \code{space} is the number of 
#'   starting value permutations to test (the size of the space to explore). The 
#'   greater the \code{dev} argument, the larger the \code{space} argument should be.
#' @param dev Specify if \code{explorestarts = TRUE}. List of length 1 or length 
#'   equal to the number of models to be evaluated. \code{dev} refers to how far 
#'   to deviate from the average parameter values when exploring (random normal 
#'   deviates). The less certain the average parameters are, the greater the 
#'   \code{dev} argument should be.
#' @param use.scalers Logical, should data be normalized? Defaults to \code{FALSE}. 
#'   Rescaling factors are the mean of the numeric vector unless specified with 
#'   \code{scaler.func}.
#' @param scaler.func Function to calculate rescaling factors. Can be a generic 
#'   function, such as mean, or a user-defined function. User-defined functions 
#'   must be specified as \code{scaler.fun = function(x, FUN = sd) 2*FUN(x)}. 
#'   This example returns two times the standard deviation of \code{x}.

#' @export discretefish_subroutine
#' @importFrom DBI dbExecute dbWriteTable dbExistsTable dbReadTable dbGetQuery dbDisconnect
#' @importFrom DT datatable JS DTOutput
#' @importFrom stats optim
#' @import shiny
#' @details Runs through model design choices generated by \code{\link{make_model_design}} 
#'   and stored as `ModelInputData` in FishSET database.  Data matrix is created 
#'   in \code{\link{create_model_input}}. Required data, optional data, and details 
#'   on likelihood functions are outlined in \code{\link{make_model_design}}. \cr\cr\cr
#'
#' Likelihood-specific initial parameter estimates: \cr
#'
#'  logit_c: \verb{  } Conditional logit likelihood \cr
#'   \verb{    }Starting parameter values takes the order of: c([alternative-specific parameters],  [travel-distance parameters]). \cr \cr
#'    The alternative-specific parameters and travel-distance parameters are of length (# of alternative-specific variables) and (# of
#'     travel-distance variables) respectively.
#'
#'  logit_avgcat:\verb{  } Average catch multinomial logit procedure \cr
#'    \verb{    } Starting parameters takes the order of: c([average-catch parameters], [travel-distance parameters]). \cr \cr
#'    The average-catch and travel-distance parameters are of length (# of average-catch variables)*(k-1) and (# of travel-distance variables)
#'    respectively, where (k) equals the number of alternative fishing choices.
#'
#'  logit_correction: \verb{  } Full information model with Dahl's correction function \cr
#'    \verb{    } Starting parameter values takes the order of: c([marginal utility from catch], [catch-function parameters],
#'    [polynomial starting parameters], [travel-distance parameters], [catch sigma]). \cr \cr
#'    The number of polynomial interaction terms is currently set to 2, so given the chosen degree 'polyn' there should be
#'     \code{"(((polyn+1)*2)+2)*(k)"} polynomial starting parameters, where (k) equals the number of alternative fishing choices.
#'    The marginal utility from catch and catch sigma are of length equal to unity respectively. The catch-function and
#'    travel-distance parameters are of length (# of catch variables)*(k) and (# of cost variables) respectively.
#'
#'  epm_normal: \verb{  } Expected profit model with normal catch function \cr
#'    \verb{    }Starting parameters values take the order of: c([catch-function parameters], [travel-distance parameters], [catch sigma(s)], [scale parameter]). \cr \cr
#'    The catch-function and travel-distance parameters are of length (# of catch-function variables)*(k) and (# of travel-distance
#'    variables) respectively, where (k) equals the number of alternative fishing choices. The catch sigma(s) are either of length equal
#'    to unity or length (k) if the analyst is estimating location-specific catch sigma parameters. The scale parameter is of length
#'    equal to unity.
#'
#'  epm_weibull: \verb{  } Expected profit model with Weibull catch function \cr,
#'   \verb{    } Starting parameter values takes the order of: c([catch-function parameters], [travel-distance parameters], [catch sigma(s)], [scale parameter]). \cr \cr
#'    The catch-function and travel-distance parameters are of length (# of catch-function variables)*(k) and (# of travel-distance variables)
#'    respectively, where (k) equals the number of alternative fishing choices. The catch sigma(s) are either of length equal to unity or
#'    length (k) if the analyst is estimating location-specific catch sigma parameters. The scale parameter is of length equal to unity.
#'
#'  epm_lognormal: \verb{ } Expected profit model with lognormal catch function \cr
#'    \verb{    } Starting parameter values takes the order of: c([catch-function parameters], [travel-distanceparameters],
#'    [catch sigma(s)], [scale parameter]). \cr\cr
#'    The catch-function and travel-distance parameters are of length (# of
#'    catch-function variables)*(k) and (# of travel-distance variables) respectively, where (k) equals the number of alternative fishing choices.
#'    The catch sigma(s) are either of length equal to unity or length (k) if the analyst is estimating location-specific catch sigma parameters.
#'    The scale parameter is of length equal to unity.
#'  \cr\cr\cr
#'
#'    Model output are saved to the FishSET database and can be loaded to the console with:
#'    \tabular{rlll}{
#'    \code{\link{model_out_view}}: \tab model output including optimization information, standard errors, coefficients, and t- statistics. \cr
#'    \code{\link{model_fit}}: \tab model comparison metrics \cr
#'    \code{\link{globalcheck_view}}: \tab  model error message \cr
#'      }
#'    For obtaining catch, choice, distance, and otherdat data generated from \code{make_model_design} function.
#'    Working ModelInputData table (table without date) will be pulled from FishSET database.
#'
#' @return
#' \tabular{rlll}{
#'   OutLogit: \tab [outmat1 se1 EPM2] (coefs, ses, tstats) \cr
#'   optoutput: \tab optimization information \cr
#'   seoumat2: \tab ses \cr
#'   MCM: \tab Model Comparison metrics \cr
#' }
#' @examples
#' \dontrun{
#' results <- discretefish_subroutine("pcod", select.model = TRUE)
#' }
#'
discretefish_subroutine <-
  
  function(project,
           select.model = FALSE,
           explorestarts = TRUE,
           breakearly = TRUE,
           space = NULL,
           dev = NULL,
           use.scalers = FALSE,
           scaler.func = NULL) {
  
  if (!isRunning()) { # if run in console
    # 
    check <- checklist(project)
    end <- any(vapply(check, function(x) x$pass == FALSE, logical(1)))
    
    if (end) stop("Model checklist incomplete.", call. = FALSE)
  }

  # Call in datasets
  if (table_exists(paste0(project, "ModelInputData"), project)) {
    
    x_temp <- unserialize_table(paste0(project, "ModelInputData"), project)
    
  } else {
    
    stop('Model input table does not exist.', call. = FALSE)
  }


  
  for (i in 1:length(x_temp)) { # loop thru each model

    x <- x_temp[[i]]
    
    length.exp.names <-length(x$expectcatchmodels)
    
    if (length.exp.names == 0) length.exp.names <- 1
    
    # data matrix ----
    # loop thru expected catch matrices (loops once if no matrix)
    for (j in seq_len(length.exp.names)) {
      
      if (is_value_empty(x$expectcatchmodels)) {
        
        exp.names <- NULL
        
      } else {
        
        exp.names <- x$expectcatchmodels[[j]]
      }
      
      datamatrix <- create_model_input(project = project, x = x, 
                                       mod.name = x$mod.name, 
                                       use.scalers = use.scalers, 
                                       scaler.func = scaler.func, 
                                       expected.catch = x$gridVaryingVariables, 
                                       exp.names = exp.names)
        
      if (is.factor(x$optimOpt)) {
        
        opt <- as.numeric(unlist(strsplit(as.character(x$optimOpt), " ")))
        
      } else if (is.list(x$optimOpt)) {
        
        opt <- as.numeric(unlist(x$optimOpt))
        
      } else {
        
        opt <- as.numeric(unlist(strsplit(as.character(x$optimOpt), " ")))
      }
    
      if (is.factor(x$initparams)) {
        
        starts2 <- as.numeric(unlist(strsplit(as.character(x$initparams), ","))) # inits
        
      } else if (is.list(x$initparams)) {
        
        starts2 <- unlist(x$initparams)
        
      } else {
        
        starts2 <-as.numeric(unlist(strsplit(as.character(x$initparams), ","))) # inits
      }
      
      errorExplain <- NULL
      OutLogit <- NULL
      optoutput <- NULL
      seoutmat2 <- NULL
      MCM <- NULL
      H1 <- NULL
      fr <- x$likelihood # func  #e.g. logit_c
      fr.name <- match.fun(find_original_name(match.fun(as.character(fr))))
    
      # Number of inits ----
      gridNum <- length(datamatrix$otherdat$griddat)
      intNum <-  length(datamatrix$otherdat$intdat)
      
      if (fr == 'logit_c') {
        
        numInits <- gridNum + intNum
        
      } else if (fr == 'logit_avgcat') {
        
        numInits <- gridNum * (max(datamatrix$choice) - 1) + intNum
        
      } else if (fr == 'logit_correction') {
        
        numInits <- gridNum * max(datamatrix$choice) + intNum + 
          ((((as.numeric(x_temp[[i]]$polyn)+1)*2)+2)*max(datamatrix$choice)) +1+1
        
      } else {
        
        numInits <- gridNum*max(datamatrix$choice)+intNum+1+1
      }
      
      if (numInits != length(starts2)) {
        
        if (length(starts2) == 1) {
          
          starts2 <- rep(starts2, numInits)
          
        } else if (numInits > length(starts2)) { # TODO: check if this is okay
          
          starts2 <- c(starts2, rep(1, (numInits - length(starts2))))
          message(numInits, ' initial parameter values should be specified')
          
        } else if (numInits < length(starts2)) { # TODO: check if this is okay
          
          starts2 <- starts2[1:numInits]
          message(numInits, ' initial parameter values should be specified')
        } 
      }

      # Explore starting parameters ----
      if (explorestarts) {
        
        sp <- if (is_empty(space[i])) 10 else space[i]
        devr <- if (is_empty(dev[i])) 5 else dev[i] 
        
        starts2 <- explore_startparams_discrete(space = sp, dev = devr, 
                                                breakearly = breakearly, 
                                                startsr = starts2, fr = fr, 
                                                d = datamatrix$d, 
                                                otherdat = datamatrix$otherdat, 
                                                choice = datamatrix$choice, 
                                                project = project)
      }
      
      # likelihood ----
      LL_start <- fr.name(starts2, datamatrix$d, datamatrix$otherdat, 
                          max(datamatrix$choice), project = project, 
                          datamatrix$expname, as.character(datamatrix$mod.name))
      
      if (is.null(LL_start) || is.nan(LL_start) || is.infinite(LL_start)) {
        # haven't checked what happens when error yet
        errorExplain <- "Initial function results bad (Nan, Inf, or undefined), check 'LDGlobalCheck'"
        cat("Initial function results bad (Nan, Inf, or undefined), check 'LDGlobalCheck'")
        next
      }

      # optim ----
      res <- c()
      mIter <- opt[1] # should add something to default options here if not specified
      relTolX <- opt[2]
      reportfreq <- opt[3]
      detailreport <- opt[4]
      
      controlin <- list(trace = detailreport, maxit = mIter, reltol = relTolX, REPORT = reportfreq)
      
      # track run time
      # if (i >= 4) browser()
      mod_time <- system.time({
        res <- 
          tryCatch({
            
            stats::optim(starts2, fr.name,
                         dat = datamatrix$d, otherdat = datamatrix$otherdat,
                         alts = max(datamatrix$choice),
                         method = as.character(x_temp[[i]][['methodname']]),
                         control = controlin, hessian = TRUE, project = project,
                         expname = datamatrix$expname,
                         mod.name = as.character(unlist(x_temp[[i]][['mod.name']])))
        },
        
        error = function(e) {
          
          return("Optimization error, check 'LDGlobalCheck'")
        })
      })[["elapsed"]]
      
      # save ld global check ----
      fishset_db <- DBI::dbConnect(RSQLite::SQLite(), locdatabase(project = project))
      on.exit(DBI::dbDisconnect(fishset_db), add = TRUE)
      
      single_sql <- paste0(project, "LDGlobalCheck", format(Sys.Date(), format = "%Y%m%d"))
      second_sql <- paste("INSERT INTO", single_sql, "VALUES (:data)")
      
      
       if (table_exists(single_sql, project=project)) {
         
         empty_dat <- 
           is_empty(
             unlist(
               DBI::dbGetQuery(fishset_db, 
                               paste0("SELECT data FROM ", single_sql, " LIMIT 1"))$data
               )
             )
         
         if (any(empty_dat)) {
           
           table_remove(single_sql, project)
           LDGlobalCheck <- LDGlobalCheck
          
         } else {
           
          x <- unserialize(DBI::dbGetQuery(fishset_db, paste0("SELECT data FROM ", single_sql, " LIMIT 1"))$data[[1]])
          table_remove(single_sql, project = project)
          LDGlobalCheck <- c(x, LDGlobalCheck)
         }
       }
      
      ld_sql <- paste0("CREATE TABLE IF NOT EXISTS ", project, "LDGlobalCheck", 
                       format(Sys.Date(), format = "%Y%m%d"), "(data LDGlobalCheck)")
      
      DBI::dbExecute(fishset_db, ld_sql)
      DBI::dbExecute(fishset_db, second_sql, 
                     params = list(data = list(serialize(LDGlobalCheck, NULL))))
      
      
      if (res[[1]][1] == "Optimization error, check 'LDGlobalCheck'") {
        
        print(
          list(
          error = paste('optimization error for', x_temp[[i]]$mod.name,
                        ', check LDGlobalCheck'),
          name = names(x_temp[[i]][["gridVaryingVariables"]])[i], 
          errorExplain = res, OutLogit = OutLogit, optoutput = optoutput,
          seoutmat2 = seoutmat2, MCM = MCM, H1 = H1
          )
        )
        
        next
      }
      
      q2 <- res[["par"]]
      LL <- res[["value"]]
      
      output <- list(
        counts = res[["counts"]], convergence = res[["convergence"]],
        optim_message = res[["message"]]
      )
      
      H <- res[["hessian"]]
  
      # Model comparison metrics (MCM) ----
      
      param <- length(starts2)
      obs <- nrow(datamatrix$dataCompile)
      AIC <- round(2 * param - 2 * LL, 3)
      
      AICc <- round(AIC + (2 * param * (param + 1)) / (obs - param - 1), 3)
      
      BIC <- round(-2 * LL + param * log(obs), 3)
      
      PseudoR2 <- round((LL_start - LL) / LL_start, 3)
      
      modOutName <- paste0(datamatrix$expname, ".", x_temp[[i]][["mod.name"]])
      
      if (!exists("mod.out")) {
        
        mod.out <- data.frame(matrix(NA, nrow = 4, ncol = 1))
        mod.out[, 1] <- c(AIC, AICc, BIC, PseudoR2)
        rownames(mod.out) <- c("AIC", "AICc", "BIC", "PseudoR2")
        colnames(mod.out) <- modOutName
        
      } else {
        
        temp <- data.frame(c(AIC, AICc, BIC, PseudoR2))
        colnames(temp) <- modOutName
      }

      if (i == 1) {
        
        if (table_exists(paste0(project, "ModelFit"), project)) {
          
          table_remove(paste0(project, "ModelFit"), project)
        }
        
        DBI::dbWriteTable(fishset_db, paste0(project, "ModelFit"), mod.out)
        
      } else {
        
        out.mod <- DBI::dbReadTable(fishset_db, paste0(project, "ModelFit"))
        
        if (exists("temp")) {
          
          out.mod <- cbind(out.mod, temp)
          
        } else {
          
          out.mod <- cbind(out.mod, mod.out)
        }
        
        if (any(duplicated(colnames(out.mod)))) {
          
          warning("Duplicate columns names. Adding numeric identifer to make colnames unique.",
                  call. = FALSE)
          colnames(out.mod) <- paste0(colnames(out.mod), 1:length(colnames(out.mod)))
        }
        
        DBI::dbWriteTable(fishset_db, paste0(project, "ModelFit"), out.mod, overwrite = TRUE)
      }
      
      ## Full model output ----
      MCM <- list(AIC = AIC, AICc = AICc, BIC = BIC, PseudoR2 = PseudoR2)
      
      single_mat_error <- "Error, singular, check 'LDGlobalCheck'"
      se_error <- "Cannot compute standard error. Check 'LDGlobalCheck'"
      
      if (is.null(H)) {
        
        print("Model error, check 'LDGlobalCheck'")
      
      } else {
        
        Htrial <- function(x) {
          
          tryCatch({
            
              solve(x)
            },
            
            error = function(e) {
              return(single_mat_error)
          })
        }
        
        print(Htrial(H))
        H1 <- Htrial(H)
        
        diagtrial <- function(x) {
          
          diagtrial <- tryCatch({
            
              diag(H1)
            },
            
            error = function(e) {
              return("Error, NAs, check 'LDGlobalCheck'")
            }
          )
          
          diagtrial
        }
        
        if (H1[1] != single_mat_error) {
          
          diag2 <- diagtrial(H1)
          print(diag2)
        }
        
        if (H1[1] != single_mat_error) {
          
          if (diag2[1] != "Error, NAs, check 'LDGlobalCheck'") {
            
            se2 <- tryCatch({
              
                sqrt(diag2)
              },
              
              warning = function(war) {
                
                print(se_error)
                sqrt(diag2)
              }
            )
            
          } else {
            
            warning = function(war) {
              
              print(se_error)
            }
          }
        }
       
        if (H1[1] != single_mat_error && se2[1]!= se_error) {
            
          seoutmat2 <- t(se2) # standard errors
          optoutput <- output # optimization info - counts, convergence, optimization error
          tLogit <- t(t(q2) / se2)
          OutLogit <- data.frame(estimate = q2, std_error = se2, t_value = tLogit)
          OutLogit <- round(OutLogit, 3)
          
        } else {
          
          outmat2 <- t(q2)
          OutLogit <- data.frame(estimate = round(q2, 3), std_error = NA, t_value = NA)
        }
        
        # TODO: make sure this works for each model type
        p_names <- unlist(lapply(x_temp[[i]]$bCHeader[-1], names))
        ec_names <- names(x_temp[[i]]$gridVaryingVariables)
        
        if (fr == "logit_avgcat") {
          
          z_names <- sort(unique(x_temp[[i]]$choice$choice))
          rownames(OutLogit) <- c(z_names, ec_names, p_names)
          
        } else {
          # Q: will this always be the correct order?
          rownames(OutLogit) <- c(ec_names, p_names)
        }
        # save to output folder
        save_table(OutLogit, project = project, x_temp[[i]]$mod.name)
        
      if (!exists("ModelOut")) {
        
        ModelOut <- list()
        ModelOut[[1]] <- list(
          name = modOutName, errorExplain = errorExplain, 
          OutLogit = OutLogit, optoutput = optoutput, seoutmat2 = seoutmat2, 
          MCM = MCM, H1 = H1, choice.table = datamatrix$choice.table, 
          params = q2, modTime = mod_time
        )
        
      } else {
        
        ModelOut[[length(ModelOut) + 1]] <- list(
          name = modOutName, errorExplain = errorExplain, 
          OutLogit = OutLogit, optoutput = optoutput, seoutmat2 = seoutmat2, 
          MCM = MCM, H1 = H1, choice.table = datamatrix$choice.table, 
          params = q2, modTime = mod_time
        )
      } 
      
      # save model output ----  
      raw_sql <- paste0(project, "ModelOut")
      single_sql <- paste0(project, "ModelOut", format(Sys.Date(), format = "%Y%m%d"))
      
      if (table_exists(single_sql, project)) {
        
        table_remove(single_sql, project)
      }
      
      if (table_exists(raw_sql, project)) {
        
        table_remove(raw_sql, project)
      }
      
      # Save ModelOut table to FSDB
      second_sql <- paste("INSERT INTO", single_sql, "VALUES (:data)")
      raw_second_sql <- paste("INSERT INTO", raw_sql, "VALUES (:data)")
      DBI::dbExecute(fishset_db, 
                     paste("CREATE TABLE IF NOT EXISTS", single_sql, "(data ModelOut)"))
      DBI::dbExecute(fishset_db, second_sql, 
                     params = list(data = list(serialize(ModelOut, NULL))))
      DBI::dbExecute(fishset_db, 
                     paste("CREATE TABLE IF NOT EXISTS", raw_sql, "(data ModelOut)"))
      DBI::dbExecute(fishset_db, raw_second_sql, 
                     params = list(data = list(serialize(ModelOut, NULL))))

      } 
    } # End looping through expected catch cases
  } # end looping through model choices
    # out.mod <<- out.mod
    
  # select model app ----
  if (select.model == TRUE) {
    #  rownames(out.mod)=c("AIC", "AICc", "BIC", "PseudoR2")
    #   print(DT::datatable(t(round(out.mod, 5)), filter='top'))
    
    shiny::runApp(list(
      ui = shiny::basicPage(
        h2("Model Output"),
        DT::DTOutput("mytable"),
        h3(""),
        actionButton("submit", "Save table", style = "color: #fff; background-color: #337ab7; border-color: #2e6da4;display:inline-block;width:12%;text-align: center;"),
        tags$button(
          id = "close",
          type = "button",
          style = "color: #fff; background-color: #FF6347; border-color: #800000; display:inline-block;width:12%;text-align: center;margin-left:10px",
          class = "btn action-button",
          onclick = "setTimeout(function(){window.close();},500);", # close browser
          "Close window"
        )
      ),
      
      server = function(input, output) {
        # helper function for making checkbox
        shinyInput <- function(FUN, len, id, ...) {
          inputs <- character(len)
          for (i in seq_len(len)) {
            inputs[i] <- as.character(FUN(paste0(id, i), label = NULL, ...))
          }
          inputs
        }
        # datatable with checkbox
        output$mytable <- shiny::renderDataTable({
          
            data.frame(t(out.mod), Select = shinyInput(checkboxInput, nrow(t(out.mod)), "cbox_"))
          },
          colnames = c("model", "AIC", "AICc", "BIC", "PseudoR2"),
          filter = "top",
          server = FALSE,
          escape = FALSE,
          options = list(
            paging = FALSE,
            preDrawCallback = DT::JS("function() { 
                                 Shiny.unbindAll(this.api().table().node()); }"),
            drawCallback = DT::JS("function() { 
                              Shiny.bindAll(this.api().table().node()); } ")
          )
        )
        # helper function for reading checkbox
        
        shinyValue <- function(id, len) {
          
          unlist(lapply(seq_len(len), function(i) {
            
            value <- input[[paste0(id, i)]]
            
            if (is.null(value)) NA else value
            })
          )
        }
        
        shinyDate <- function(id, len) {
          unlist(lapply(seq_len(len), function(i) {
            # value = input[[paste0(id, i)]]
            # if (is.null(value)) NA else value
            value <- ifelse(input[[paste0(id, i)]] != TRUE, "", as.character(Sys.Date()))
          }))
        }
        
        checkedsave <- reactive(cbind(
          model = colnames(out.mod), t(out.mod),
          selected = shinyValue("cbox_", nrow(t(out.mod))),
          Date = shinyDate("cbox_", nrow(t(out.mod)))
        ))
        
        
        # When the Submit button is clicked, save the form data
        observeEvent(input$submit, {
          # Connect to the database
          #fishset_db <- DBI::dbConnect(RSQLite::SQLite(), locdatabase(project=project))
          single_sql <- paste0(project, "modelChosen")
          if (DBI::dbExistsTable(fishset_db, single_sql) == FALSE) {
            DBI::dbExecute(fishset_db, paste0("CREATE TABLE ", single_sql, "(model TEXT, AIC TEXT, AICc TEXT, BIC TEXT, PseudoR2 TEXT, selected TEXT, Date TEXT)"))
          }
          # Construct the update query by looping over the data fields
          query <- sprintf(
            "INSERT INTO %s (%s) VALUES %s",
            single_sql,
            paste(names(data.frame(as.data.frame(isolate(checkedsave())))), collapse = ", "),
            paste0("('", matrix(apply(as.data.frame(isolate(checkedsave())), 1, paste, collapse = "','"), ncol = 1), collapse = ",", "')")
          )
          # Submit the update query and disconnect
          DBI::dbGetQuery(fishset_db, query)
          showNotification("Table saved to database")
          
          #Save 
        })
        
        observeEvent(input$close, stopApp())
      }
    ))
  } # end select.model
  
  
  # log ----

  discretefish_subroutine_function <- list()
  discretefish_subroutine_function$functionID <- "discretefish_subroutine"
  discretefish_subroutine_function$args <- list(project, select.model)
  discretefish_subroutine_function$kwargs <- list()
  log_call(project, discretefish_subroutine_function)
  
  single_sql <- paste0(project, "ModelOut", format(Sys.Date(), format = "%Y%m%d"))
  
  if (table_exists(single_sql, project)) {
    # TODO: determine what this block is for, returning parameters?
    out <- 
      unserialize(
        DBI::dbGetQuery(fishset_db, 
                        paste0("SELECT data FROM ", single_sql, " LIMIT 1"))$data[[1]])
    # return(out)
  }
}

