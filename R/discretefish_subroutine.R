# discretefish_subroutine
#' Run discrete choice model
#'
#' Subroutine to run chosen discrete choice model. Function pulls necessary data generated in \code{\link{make_model_design}} and loops through model design choices and expected catch cases. Output is saved to the FishSET database.
#'
#' @param project  String, name of project.
#' @param select.model Return an interactive data table that allows users to select and save table of best models based on measures of fit.
#' @param explorestarts Logical, should starting parameters value space be explored? Set to TRUE if unsure of the number of 
#'    starting parameter values to include or of reasonable starting parameters values. Better starting parameter values
#'    can help with model convergence.
#' @param breakearly Logical, if explorestarts is TRUE, should the first set of starting parameter values that returns a valid (numeric)
#'   loglikelihoood value be returned (TRUE) or should the entire parameter space be considered and the set of starting parameter values 
#'   that return the lowest loglikelihood value be returned (FALSE).
#' @param space Specify if \code{explorestarts = TRUE}. List of length 1 or length equal to the number of models to be evaluated.
#'   \code{space} is the number of starting value permutations to test (the size of
#'   the space to explore). The greater the \code{dev} argument, the larger the
#'   \code{space} argument should be.
#' @param dev Specify if \code{explorestarts = TRUE}. List of length 1 or length equal to the number of models to be evaluated.
#'   \code{dev} refers to how far to deviate from the average parameter values when
#'   exploring (random normal deviates). The less certain the average parameters are,
#'   the greater the \code{dev} argument should be.
#' @param use.scalers Logical, should data be noramalized? Defaults to TRUE. Rescaling factors are the mean of the numeric vector unless specified with \code{scaler}.
#' @param scaler.func Function to calculate rescaling factors. Can be a generic function, such as mean, or a user-defined function.
#'   User-defined functons must be specified as \code{scaler.fun = function(x, FUN=sd) 2*FUN(x)}. This example returns 2 times the standard deviation of \code{x}.

#' @export discretefish_subroutine
#' @importFrom DBI dbExecute dbWriteTable dbExistsTable dbReadTable dbGetQuery dbDisconnect
#' @importFrom DT datatable JS DTOutput
#' @importFrom stats optim
#' @import shiny
#' @details Runs through model design choices generated by \code{\link{make_model_design}} and stored as `modelInputData` in 
#'     FishSET database.  Data matrix is created in \code{\link{create_model_input}}. 
#'     Required data, optional data, and details on likelihood functions are outlined in \code{\link{make_model_design}}. \cr\cr\cr
#'
#' Likelihood-specific initial parameter estimates: \cr
#'
#'  logit_c: \verb{  } Conditional logit likelihood \cr
#'   \verb{    }Starting parameter values takes the order of: c([alternative-specific parameters],  [travel-distance parameters]). \cr \cr
#'    The alternative-specific parameters and travel-distance parameters are of length (# of alternative-specific variables) and (# of
#'     travel-distance variables) respectively.
#'
#'  logit_avgcat:\verb{  } Average catch multinomial logit procedure \cr
#'    \verb{    } Starting parameters takes the order of: c([average-catch parameters], [travel-distance parameters]). \cr \cr
#'    The average-catch and travel-distance parameters are of length (# of average-catch variables)*(k-1) and (# of travel-distance variables)
#'    respectively, where (k) equals the number of alternative fishing choices.
#'
#'  logit_correction: \verb{  } Full information model with Dahl's correction function \cr
#'    \verb{    } Starting parameter values takes the order of: c([marginal utility from catch], [catch-function parameters],
#'    [polynomial starting parameters], [travel-distance parameters], [catch sigma]). \cr \cr
#'    The number of polynomial interaction terms is currently set to 2, so given the chosen degree 'polyn' there should be
#'     \code{"(((polyn+1)*2)+2)*(k)"} polynomial starting parameters, where (k) equals the number of alternative fishing choices.
#'    The marginal utility from catch and catch sigma are of length equal to unity respectively. The catch-function and
#'    travel-distance parameters are of length (# of catch variables)*(k) and (# of cost variables) respectively.
#'
#'  epm_normal: \verb{  } Expected profit model with normal catch function \cr
#'    \verb{    }Starting parameters values take the order of: c([catch-function parameters], [travel-distance parameters], [catch sigma(s)], [scale parameter]). \cr \cr
#'    The catch-function and travel-distance parameters are of length (# of catch-function variables)*(k) and (# of travel-distance
#'    variables) respectively, where (k) equals the number of alternative fishing choices. The catch sigma(s) are either of length equal
#'    to unity or length (k) if the analyst is estimating location-specific catch sigma parameters. The scale parameter is of length
#'    equal to unity.
#'
#'  epm_weibull: \verb{  } Expected profit model with Weibull catch function \cr,
#'   \verb{    } Starting parameter values takes the order of: c([catch-function parameters], [travel-distance parameters], [catch sigma(s)], [scale parameter]). \cr \cr
#'    The catch-function and travel-distance parameters are of length (# of catch-function variables)*(k) and (# of travel-distance variables)
#'    respectively, where (k) equals the number of alternative fishing choices. The catch sigma(s) are either of length equal to unity or
#'    length (k) if the analyst is estimating location-specific catch sigma parameters. The scale parameter is of length equal to unity.
#'
#'  epm_lognormal: \verb{ } Expected profit model with lognormal catch function \cr
#'    \verb{    } Starting parameter values takes the order of: c([catch-function parameters], [travel-distanceparameters],
#'    [catch sigma(s)], [scale parameter]). \cr\cr
#'    The catch-function and travel-distance parameters are of length (# of
#'    catch-function variables)*(k) and (# of travel-distance variables) respectively, where (k) equals the number of alternative fishing choices.
#'    The catch sigma(s) are either of length equal to unity or length (k) if the analyst is estimating location-specific catch sigma parameters.
#'    The scale parameter is of length equal to unity.
#'  \cr\cr\cr
#'
#'    Model output are saved to the FishSET database and can be loaded to the console with:
#'    \tabular{rlll}{
#'    \code{\link{model_out_view}}: \tab model output including optimization information, standard errors, coefficients, and t- statistics. \cr
#'    \code{\link{model_fit}}: \tab model comparison metrics \cr
#'    \code{\link{globalcheck_view}}: \tab  model error message \cr
#'      }
#'    For obtaining catch, choice, distance, and otherdat data generated from \code{make_model_design} function.
#'    Working modelInputData table (table without date) will be pulled from FishSET database.
#'
#' @return
#' \tabular{rlll}{
#'   OutLogit: \tab [outmat1 se1 EPM2] (coefs, ses, tstats) \cr
#'   optoutput: \tab optimization information \cr
#'   seoumat2: \tab ses \cr
#'   MCM: \tab Model Comparison metrics \cr
#' }
#' @examples
# # choice <- as.data.frame(modelInputData$choice)
# # alt.choice <- as.data.frame(as.numeric(as.factor(as.numeric(as.data.frame(modelInputData$choice)[,1]))))
# # griddatfin <- list(predicted_catch=modelInputData$gridVaryingVariables$matrix)
# # intdatfin <- list(modelInputData$bCHeader[[-1]])
#' \dontrun{
#' results <- discretefish_subroutine("pcod", select.model = TRUE)
#' }
#'
discretefish_subroutine <- function(project, select.model = FALSE, explorestarts = TRUE, breakearly= TRUE,
                                    space=NULL, dev=NULL, use.scalers=TRUE, scaler.func=NULL) {

end <- FALSE

    if (!isRunning()) { # if run in console
    
    check <- checklist(project)
    end <- any(vapply(check, function(x) x$pass == FALSE, logical(1)))
  }

 
  if (end == FALSE) {

    # Call in datasets
    fishset_db <- DBI::dbConnect(RSQLite::SQLite(), locdatabase(project=project))
    on.exit(DBI::dbDisconnect(fishset_db), add = TRUE)
    x_temp <- unserialize(DBI::dbGetQuery(fishset_db, paste0("SELECT ModelInputData FROM ", project, "modelinputdata LIMIT 1"))$ModelInputData[[1]])
    
    
    for (i in 1:length(x_temp)) {

      x <- x_temp[[i]]
      if (!is.null(x$mod.name) & x$likelihood!='logit_c'){
            exp.names <- NULL
      } else {
            exp.names <- c("short_exp","short_exp_newDumV","med_exp","med_exp_newDumV","long_exp","long__exp_newDumv","user_defined_exp")
      }  
        
        for(j in 1:length(exp.names)){
          data.matrix <- create_model_input(project=project, x=x, mod.name=x$mod.name, use.scalers= use.scalers, scaler.func=scaler.func, expected.catch.name=exp.names[j])
        


       
      
      #Scalers
 #     scale.func <- function(s, d){
 #             if(!is.list(s)) {
 #               s <- as.list(s)
 #             } 
 #             if(length(d) == length(s)){
 #              for(k in 1:length(d)) {  
 #               d[k] <- unlist(s)[k]
 #             }} else {
 #               message('Insufficient scaling factor values supplied. Defaulting to 2*sd.')
 #               
 #           }
 #       return(d)
 #         }

       #Scalers
#      scale.func <- function(s, d){
#              if(!is.list(s)) {
#                s <- as.list(s)
#              } 
#              if(length(d) == length(s)){
#               for(k in 1:length(d)) {  
#                d[k] <- unlist(s)[k]
#              }} else {
#                message('Insufficient scaling factor values supplied. Defaulting to 2*sd.')
#                
#            }
 #       return(d)
 #         }
      
#    if(use.scalers == TRUE && !is.null(scaler.func)){
#          if(!is.character(scaler.func)){
#          
#           x_temp[[i]]$scales[1] <- scaler.func(x_temp[[i]][["catch"]])
#            x_temp[[i]]$scales[2] <-  scaler.func(x_temp[[i]][["distance"]])
#            x_temp[[i]]$scales[3] <-  scaler.func(x_temp[[i]][["bCHeader"]][["gridVariablesInclude"]])
#            if(is.list(x_temp[[i]][["bCHeader"]][["indeVarsForModel"]])){
#              x_temp[[i]]$scales[4]:length(x_temp[[i]]$scales) <- lapply(x_temp[[i]][["bCHeader"]][["indeVarsForModel"]], function(x) scaler.func(unlist(x)))
#            } else {
#              x_temp[[i]]$scales[4]:length(x_temp[[i]]$scales) <- scaler.func(x_temp[[i]][["bCHeader"]][["indeVarsForModel"]]) 
#            }
#           
#         } 
##         } else if(use.scalers == FALSE) {
#        for(k in 1:length(x_temp[[i]]$scales)) { 
#          x_temp[[i]]$scales[k] <- 1
#          }
#         }
      
      
#      catch <- (data.frame(as.matrix(x_temp[[i]][["catch"]])))/x_temp[[i]]$scales[1]
#      choice <- x_temp[[i]][["choice"]]
#     distance <- (data.frame(x_temp[[i]][["distance"]]))/x_temp[[i]]$scales[2]
#      startingloc <- x_temp[[i]][["startingloc"]]
      # otherdat <- list(griddat=list(griddatfin=x[['gridVaryingVariables']][['matrix']]), intdat=list(x[['bCHeader']][[-1]]), pricedata=list(epmDefaultPrice))
 #     mod.name <- unlist(x_temp[[i]][["mod.name"]])
      #opt <- unlist(x_temp[[i]][["optimOpt"]])
      #starts2 <- unlist(x_temp[[i]][["initparams"]])
 #     polyn <- NA
      
      
      if (is.factor(x_temp[[i]][["optimOpt"]])) {
            opt <- as.numeric(unlist(strsplit(as.character(x_temp[[i]][["optimOpt"]]), " ")))
          } else if(is.list(x_temp[[i]][["optimOpt"]])){
            opt <- as.numeric(unlist(x_temp[[i]][["optimOpt"]]))
          } else {
            opt <- as.numeric(unlist(strsplit(as.character(x_temp[[i]][["optimOpt"]]), " ")))
          }
      
          if (is.factor(x_temp[[i]][["initparams"]])) {
            starts2 <- as.numeric(unlist(strsplit(as.character(x_temp[[i]][["initparams"]]), ","))) # inits
          } else if(is.list(x_temp[[i]][["initparams"]])){
            starts2 <- unlist(x_temp[[i]][["initparams"]])
          } else {
            starts2 <-as.numeric(unlist(strsplit(as.character(x_temp[[i]][["initparams"]]), ","))) # inits
          }
      
#      choice.table <- as.matrix(choice, as.numeric(factor(choice)))
#      choice <- data.frame(as.matrix(as.numeric(factor(choice))))
#      ab <- max(choice) + 1 # no interactions in create_logit_input - interact distances in likelihood function instead
      
      errorExplain <- NULL
      OutLogit <- NULL
      optoutput <- NULL
      seoutmat2 <- NULL
      MCM <- NULL
      H1 <- NULL
      fr <- x_temp[[i]][["likelihood"]] # func  #e.g. logit_c
      fr.name <- match.fun(find_original_name(match.fun(as.character(fr))))
      
      # remove unnecessary lists
#      x_temp[[i]][["gridVaryingVariables"]] <- Filter(Negate(function(x) is.null(unlist(x))), x_temp[[i]][["gridVaryingVariables"]])
#      x_temp[[i]][["gridVaryingVariables"]] <- x_temp[[i]][["gridVaryingVariables"]][names(x_temp[[i]][["gridVaryingVariables"]]) != "units"]
#      x_temp[[i]][["gridVaryingVariables"]] <- x_temp[[i]][["gridVaryingVariables"]][names(x_temp[[i]][["gridVaryingVariables"]]) != "scale"]
      
            #Identify the number of inits required



#      if (fr == "logit_correction" & all(is.na(startingloc))) {
#        warning("Startingloc parameter is not specified. Rerun the create_alternative_choice function")
#      }
#      dataCompile <- create_logit_input(choice)

#      d <- shift_sort_x(dataCompile, choice, catch, distance, max(choice), ab)
      
      # starts2 <-as.numeric(unlist(strsplit(as.character(inits), ","))) # inits
      
      ### Data needs will vary by the likelihood function ###
#      if (grepl("epm", fr)) {
#        otherdat <- list(
#          griddat = list(griddatfin = as.data.frame(x_temp[[i]][["bCHeader"]][["gridVariablesInclude"]])/x_temp[[i]]$scales[3]),
#          intdat = list(as.data.frame(
#            mapply("/",x_temp[[i]][["bCHeader"]][["indeVarsForModel"]],
#                   x_temp[[i]]$scales[c(4:length(x_temp[[i]]$scales))],SIMPLIFY = FALSE))),
#          pricedat = as.data.frame(x_temp[[i]][["epmDefaultPrice"]])
#        )
#        nexpcatch <- 1
#        expname <- fr
#      } else if (fr == "logit_correction") {
#        otherdat <- list(
 #         griddat = list(griddatfin = data.frame(rep(1, nrow(choice)))), # x[['bCHeader']][['gridVariablesInclude']]),
#          intdat = list(as.data.frame(mapply("/",x_temp[[i]][["bCHeader"]][["indeVarsForModel"]],
#                          x_temp[[i]]$scales[c(4:length(x_temp[[i]]$scales))],SIMPLIFY = FALSE))),
#          startloc = as.data.frame(x_temp[[i]][["startloc"]]),
 #         polyn = as.data.frame(x_temp[[i]][["polyn"]])
#        )
#        nexpcatch <- 1
#        expname <- fr
#      } else if (fr == "logit_avgcat") {
#        otherdat <- list(
#          griddat = list(griddatfin = data.frame(rep(1, nrow(choice)))), # x[['bCHeader']][['gridVariablesInclude']]),
#          intdat = list(as.data.frame(
#                                  mapply("/",x_temp[[i]][["bCHeader"]][["indeVarsForModel"]],
#                                         x_temp[[i]]$scales[c(4:length(x_temp[[i]]$scales))],SIMPLIFY = FALSE)))
#        )
#        nexpcatch <- 1
#        expname <- fr
#      } else if (fr == "logit_c") {
#        nexpcatch <- length(names(x_temp[[i]][["gridVaryingVariables"]]))
#      }
#      # Begin loop
#      for (j in 1:nexpcatch) {
#        if (fr == "logit_c") {
#          expname <- paste0(names(x_temp[[i]][["gridVaryingVariables"]])[j], "_", fr)
#          otherdat <- list(
#            griddat = list(griddatfin = as.data.frame(x_temp[[i]][["gridVaryingVariables"]][[names(x_temp[[i]][["gridVaryingVariables"]])[j]]])/x_temp[[i]]$scales[3]),
#            intdat = list(as.data.frame(
#                           mapply("/",x_temp[[i]][["bCHeader"]][["indeVarsForModel"]],
#                                  x_temp[[i]]$scales[c(4:length(x_temp[[i]]$scales))],SIMPLIFY = FALSE)))
#          )
#        }
        
        # Get data
        
        
        
        #Number of inits
        gridNum <- length(data.matrix$otherdat$griddat[[1]])
        intNum <-  length(data.matrix$otherdat$intdat[[1]])
        if(fr == 'logit_c'){
          numInits <- gridNum+intNum
        } else if(fr == 'logit_avgcat') {
          numInits <- gridNum*(max(data.matrix$choice)-1)+intNum
        } else if(fr == 'logit_correction'){
          numInits <- gridNum*4 + intNum + ((((x_temp[[i]]$polyn+1)*2)+2)*4) +1+1
        } else {
#          if(input$lockk=='TRUE'){
#            numInits <- gridNum*max(choice)+intNum+alt+1
#          } else {
            numInits <- gridNum*max(data.matrix$choice)+intNum+1+1
#          }
        }
        if(numInits != length(starts2)){
          if(numInits > length(starts2)){
            starts2 <- c(starts2, rep(0.5, (numInits - length(starts2))))
            message(numInits, ' initial parameter values should be specified')
          } else if (numInits < length(starts2)){
            starts2 <- starts2[1:numInits]
            message(numInits, ' initial parameter values should be specified')
          } else {
            starts2 <- starts2
          }
        }
        
        
        #Explore starting parameters
        if(explorestarts==TRUE){
          sp <- if(is.null(space[i])) {10} else { space[i] }
          devr <- if(is.null(dev[i])) { 5} else { dev[i] }
          
          starts2 <- explore_startparams_discrete(space=sp, dev=devr, breakearly=breakearly, startsr=starts2, fr=fr, 
                                                  d=data.matrix$d, otherdat=data.matrix$otherdat, choice=data.matrix$choice, project=project)
        }
        
        LL_start <- fr.name(starts2, data.matrix$d, data.matrix$otherdat, max(data.matrix$choice), 
                            project =project, data.matrix$expname, as.character(data.matrix$mod.name))
        
        if (is.null(LL_start) || is.nan(LL_start) || is.infinite(LL_start)) {
          # haven't checked what happens when error yet
          errorExplain <- "Initial function results bad (Nan, Inf, or undefined), check 'ldglobalcheck'"
          cat("Initial function results bad (Nan, Inf, or undefined), check 'ldglobalcheck'")
          next
        }

        #############################################################################
        mIter <- opt[1] # should add something to default options here if not specified
        relTolX <- opt[2]
        reportfreq <- opt[3]
        detailreport <- opt[4]
        
        controlin <- list(trace = detailreport, maxit = mIter, reltol = relTolX, REPORT = reportfreq)
        
        res <- tryCatch(
          {
            stats::optim(starts2, fr.name,
                         dat = data.matrix$d, otherdat = data.matrix$otherdat, alts = max(data.matrix$choice), 
                         method = as.character(x_temp[[i]][['methodname']]), control = controlin, hessian = TRUE, 
                         project = project, expname = data.matrix$expname, mod.name = as.character(unlist(x_temp[[i]][['mod.name']]))
            )
          },
          error = function(e) {
            return("Optimization error, check 'ldglobalcheck'")
          }
        )
        
        if (res[[1]][1] == "Optimization error, check 'ldglobalcheck'") {
          print(list(
            name = names(x_temp[[i]][["gridVaryingVariables"]])[i], errorExplain = res, OutLogit = OutLogit, optoutput = optoutput,
            seoutmat2 = seoutmat2, MCM = MCM, H1 = H1
          ))
          next
        }
        
        q2 <- res[["par"]]
        LL <- res[["value"]]
        output <- list(
          counts = res[["counts"]], convergence = res[["convergence"]],
          optim_message = res[["message"]]
        )
        H <- res[["hessian"]]
        
    
        #############################################################################
        # Model comparison metrics (MCM)
        param <- max(dim(as.matrix(starts2)))
        obs <- dim(data.matrix$dataCompile)[1]
        AIC <- round(2 * param - 2 * LL, 3)
        
        AICc <- round(AIC + (2 * param * (param + 1)) / (obs - param - 1), 3)
        
        BIC <- round(-2 * LL + param * log(obs), 3)
        
        PseudoR2 <- round((LL_start - LL) / LL_start, 3)
        if (!exists("mod.out")) {
          mod.out <- data.frame(matrix(NA, nrow = 4, ncol = 1))
          mod.out[, 1] <- c(AIC, AICc, BIC, PseudoR2)
          rownames(mod.out) <- c("AIC", "AICc", "BIC", "PseudoR2")
          colnames(mod.out) <- paste0(data.matrix$expname, x_temp[[i]][["mod.name"]])
        } else {
          temp <- data.frame(c(AIC, AICc, BIC, PseudoR2))
          colnames(temp) <- paste0(data.matrix$expname, x_temp[[i]][["mod.name"]])
        }
        
        fishset_db <- DBI::dbConnect(RSQLite::SQLite(), locdatabase(project=project))
        
        if (i == 1) {
          if(table_exists(paste0(project, "modelfit"), project)){
          table_remove(paste0(project, "modelfit"), project)
          }
          DBI::dbWriteTable(fishset_db, paste0(project, "modelfit"), mod.out)
        } else {
          out.mod <- DBI::dbReadTable(fishset_db, paste0(project, "modelfit"))
          if (exists("temp")) {
            out.mod <- cbind(out.mod, temp)
          } else {
            out.mod <- cbind(out.mod, mod.out)
          }
          
          if (any(duplicated(colnames(out.mod))) == T) {
            warning("Duplicate columns names. Adding numeric identifer to make colnames unique.")
            colnames(out.mod) <- paste0(colnames(out.mod), 1:length(colnames(out.mod)))
          }
          DBI::dbWriteTable(fishset_db, paste0(project, "modelfit"), out.mod, overwrite = T)
        }
        
        ### Full model output
        MCM <- list(AIC = AIC, AICc = AICc, BIC = BIC, PseudoR2 = PseudoR2)
        
        if (is.null(H) == FALSE) {
          Htrial <- function(x) {
            Htrial <- tryCatch(
              {
                solve(H)
              },
              error = function(e) {
                return("Error, singular, check 'ldglobalcheck'")
              }
            )
            Htrial
          }
          print(Htrial(H))
          H1 <- Htrial(H)
          
          
          diagtrial <- function(x) {
            diagtrial <- tryCatch(
              {
                diag(H1)
              },
              error = function(e) {
                return("Error, NAs, check 'ldglobalcheck'")
              }
            )
            diagtrial
          }
          if (H1[1] != "Error, singular, check 'ldglobalcheck'") {
            diag2 <- diagtrial(H1)
            print(diag2)
          }
          
          
          if (H1[1] != "Error, singular, check 'ldglobalcheck'") {
            if (diag2[1] != "Error, NAs, check 'ldglobalcheck'") {
              se2 <- tryCatch(
                {
                  sqrt(diag2)
                },
                warning = function(war) {
                  print("Check 'ldglobalcheck'")
                  sqrt(diag2)
                }
              )
            }
          }
          
          if (H1[1] != "Error, singular, check 'ldglobalcheck'") {
            outmat2 <- t(q2) #best set of parameters found
            seoutmat2 <- t(se2) #standard errors
            optoutput <- output #optimization info - counts, convergence, optimization error
            tLogit <- t(outmat2 / se2)
            OutLogit <- cbind(t(outmat2), as.matrix(se2), (tLogit))
          }
        }
        
        # if(H1[1]!="Error, singular, check 'ldglobalcheck'") next
        
        if(!exists("modelOut")) {
          modelOut <- list()
          modelOut[[length(modelOut) + 1]] <- list(
            name = data.matrix$expname, errorExplain = errorExplain, OutLogit = OutLogit, optoutput = optoutput,
            seoutmat2 = seoutmat2, MCM = MCM, H1 = H1, choice.table = data.matrix$choice.table
          )
        } else {
          modelOut[[length(modelOut) + 1]] <- list(
            name = data.matrix$expname, errorExplain = errorExplain, OutLogit = OutLogit, optoutput = optoutput,
            seoutmat2 = seoutmat2, MCM = MCM, H1 = H1, choice.table = data.matrix$choice.table
          )
        } 
        raw_sql <- paste0(project, "modelOut")
        single_sql <- paste0(project, "modelOut", format(Sys.Date(), format = "%Y%m%d"))
        if (table_exists(single_sql, project)) {
          table_remove(single_sql, project)
        }
        if (table_exists(raw_sql, project)) {
          table_remove(raw_sql, project)
        }
        
        # save param ests, se, and t-vals to output folder
        if (!is.null(OutLogit)) {
          
          params_out <- as.data.frame(OutLogit)
          names(params_out) <- c("estimate", "std_error", "t_value") 
          rownames(params_out) <- levels(factor(x_temp[[i]]$choice))
          params_out <- round(params_out, 3)

          save_table(params_out, project=project, x_temp[[i]]$mod.name)

#          save_table(params_out, paste0(project, '_params'), x_temp[[i]]$mod.name)
        }
        
        second_sql <- paste("INSERT INTO", single_sql, "VALUES (:data)")
        raw_second_sql <- paste("INSERT INTO", raw_sql, "VALUES (:data)")
        DBI::dbExecute(fishset_db, paste("CREATE TABLE IF NOT EXISTS", single_sql, "(data modelOut)"))
        DBI::dbExecute(fishset_db, second_sql, params = list(data = list(serialize(modelOut, NULL))))
        DBI::dbExecute(fishset_db, paste("CREATE TABLE IF NOT EXISTS", raw_sql, "(data modelOut)"))
        DBI::dbExecute(fishset_db, raw_second_sql, params = list(data = list(serialize(modelOut, NULL))))
        DBI::dbDisconnect(fishset_db)

      }## End looping through expected catch cases
    } # end looping through model choices
    } # end model run (if end == false)
    # out.mod <<- out.mod
    #############################################################################
    if (select.model == TRUE) {
      #  rownames(out.mod)=c("AIC", "AICc", "BIC", "PseudoR2")
      #   print(DT::datatable(t(round(out.mod, 5)), filter='top'))
      
      shiny::runApp(list(
        ui = shiny::basicPage(
          h2("Model Output"),
          DT::DTOutput("mytable"),
          h3(""),
          actionButton("submit", "Save table", style = "color: #fff; background-color: #337ab7; border-color: #2e6da4;display:inline-block;width:12%;text-align: center;"),
          tags$button(
            id = "close",
            type = "button",
            style = "color: #fff; background-color: #FF6347; border-color: #800000; display:inline-block;width:12%;text-align: center;margin-left:10px",
            class = "btn action-button",
            onclick = "setTimeout(function(){window.close();},500);", # close browser
            "Close window"
          )
        ),
        
        server = function(input, output) {
          # helper function for making checkbox
          shinyInput <- function(FUN, len, id, ...) {
            inputs <- character(len)
            for (i in seq_len(len)) {
              inputs[i] <- as.character(FUN(paste0(id, i), label = NULL, ...))
            }
            inputs
          }
          # datatable with checkbox
          output$mytable <- shiny::renderDataTable(
            {
              data.frame(t(out.mod), Select = shinyInput(checkboxInput, nrow(t(out.mod)), "cbox_"))
            },
            colnames = c("model", "AIC", "AICc", "BIC", "PseudoR2"),
            filter = "top",
            server = FALSE,
            escape = FALSE,
            options = list(
              paging = FALSE,
              preDrawCallback = DT::JS("function() { 
                                   Shiny.unbindAll(this.api().table().node()); }"),
              drawCallback = DT::JS("function() { 
                                Shiny.bindAll(this.api().table().node()); } ")
            )
          )
          # helper function for reading checkbox
          
          shinyValue <- function(id, len) {
            unlist(lapply(seq_len(len), function(i) {
              value <- input[[paste0(id, i)]]
              if (is.null(value)) NA else value
            }))
          }
          
          shinyDate <- function(id, len) {
            unlist(lapply(seq_len(len), function(i) {
              # value = input[[paste0(id, i)]]
              # if (is.null(value)) NA else value
              value <- ifelse(input[[paste0(id, i)]] != TRUE, "", as.character(Sys.Date()))
            }))
          }
          
          checkedsave <- reactive(cbind(
            model = colnames(out.mod), t(out.mod),
            selected = shinyValue("cbox_", nrow(t(out.mod))),
            Date = shinyDate("cbox_", nrow(t(out.mod)))
          ))
          
          
          # When the Submit button is clicked, save the form data
          observeEvent(input$submit, {
            # Connect to the database
            fishset_db <- DBI::dbConnect(RSQLite::SQLite(), locdatabase(project=project))
            single_sql <- paste0(project, "modelChosen")
            if (DBI::dbExistsTable(fishset_db, single_sql) == FALSE) {
              DBI::dbExecute(fishset_db, paste0("CREATE TABLE ", single_sql, "(model TEXT, AIC TEXT, AICc TEXT, BIC TEXT, PseudoR2 TEXT, selected TEXT, Date TEXT)"))
            }
            # Construct the update query by looping over the data fields
            query <- sprintf(
              "INSERT INTO %s (%s) VALUES %s",
              single_sql,
              paste(names(data.frame(as.data.frame(isolate(checkedsave())))), collapse = ", "),
              paste0("('", matrix(apply(as.data.frame(isolate(checkedsave())), 1, paste, collapse = "','"), ncol = 1), collapse = ",", "')")
            )
            # Submit the update query and disconnect
            DBI::dbGetQuery(fishset_db, query)
            showNotification("Table saved to database")
          })
          
          # stop shiny
          observe({
            if (input$close > 0) stopApp()
          })
        }
      ))
    } # end select.model
    
    #############################################################################
    discretefish_subroutine_function <- list()
    discretefish_subroutine_function$functionID <- "discretefish_subroutine"
    discretefish_subroutine_function$args <- list(project, select.model)
    discretefish_subroutine_function$kwargs <- list()
    log_call(project, discretefish_subroutine_function)
    #############################################################################
    single_sql <- paste0(project, "modelOut", format(Sys.Date(), format = "%Y%m%d"))
    if (table_exists(single_sql, project)) {
      fishset_db <- DBI::dbConnect(RSQLite::SQLite(), locdatabase(project=project))
      out <- unserialize(DBI::dbGetQuery(fishset_db, paste0("SELECT data FROM ", single_sql, " LIMIT 1"))$data[[1]])
      # return(out)
      DBI::dbDisconnect(fishset_db)
    }

}

